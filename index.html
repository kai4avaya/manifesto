<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Process Manifesto</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,700;1,400&family=Playfair+Display:wght@700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lora', serif;
            background-color: #f5f5f4; /* Stone 100 */
            color: #1c1917; /* Stone 900 */
        }
        .manifesto-text h1, .manifesto-text h2 {
            font-family: 'Playfair Display', serif;
        }
        
        /* Hide scrollbar */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Frosted Glass Effect */
        .glass-pane {
            background-color: rgba(245, 245, 244, 0.75); /* Stone 100 with opacity */
            backdrop-filter: blur(0px);
            -webkit-backdrop-filter: blur(16px);
        }
        
        .animation-parent {
            perspective: 1200px;
        }
        #animation-container {
            transition: transform 0.4s ease-out;
        }
        
        /* Grid line transitions */
        #animation-container svg #grid-wrapper {
             transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #animation-container svg line {
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }


    </style>
</head>
<body class="overflow-hidden">

    <div class="relative w-full h-screen">
        <!-- Background Animation Pane -->
        <div class="hidden lg:block fixed top-0 left-0 w-full h-full animation-parent">
            <div id="animation-container" class="w-full h-full transition-opacity duration-500 ease-in-out">
                <!-- JS will populate this with SVG -->
            </div>
        </div>

        <!-- Foreground Text Pane -->
        <div id="manifesto-content" class="manifesto-text absolute top-0 left-0 w-full lg:w-1/2 h-screen overflow-y-auto p-8 md:p-12 lg:p-16 no-scrollbar glass-pane">
            <div class="max-w-prose space-y-10">
                <section data-section="0" class="min-h-[50vh] py-16">
                    <h1 class="text-4xl md:text-5xl font-bold text-stone-900 mb-6">The Process Manifesto</h1>
                    <p class="text-lg text-stone-700 leading-relaxed">Our company is not built to create products. Our company is built to create process. The products we release are artifacts of that learning—experiments we run to test, measure, and refine the process itself.</p>
                </section>

                <section data-section="1" class="min-h-[50vh] py-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-stone-900 mb-8">Core Principles</h2>
                    <ul class="space-y-6 text-stone-600">
                        <li><strong class="font-semibold text-stone-800">The Process is the Product.</strong> Our primary goal is to master the system of creation. We build software to understand how to build software better.</li>
                        <li><strong class="font-semibold text-stone-800">Build to Learn.</strong> We default to building our own tools, frameworks, and platforms. This forces a first-principles understanding. These internal tools are our most valuable assets and potential future products.</li>
                        <li><strong class="font-semibold text-stone-800">Pragmatism Over Dogma.</strong> We build by default, but we are pragmatic. We use the best tool for the job, whether we built it or not. The goal is to improve the process, not to prove a point.</li>
                        <li><strong class="font-semibold text-stone-800">Radical Agility.</strong> We are loyal to the process, not to a specific tool, feature, or product. If a component of our system—internal or external—is not working, we abandon it and iterate.</li>
                    </ul>
                </section>

                <section data-section="2" class="min-h-[50vh] py-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-stone-900 mb-8">How We Operate</h2>
                    <ul class="space-y-6 text-stone-600">
                        <li><strong class="font-semibold text-stone-800">AI-Human Unification.</strong> We do not see AI and human engineers as separate. We build unified pipelines where AI automates, assists, and accelerates human effort. If a task can be automated or augmented by AI, it will be.</li>
                        <li><strong class="font-semibold text-stone-800">Constant Experimentation.</strong> The state of the art is our starting line. We actively seek out and implement the latest tools, models, and techniques to test their impact on our process.</li>
                        <li><strong class="font-semibold text-stone-800">Document and Share.</strong> A process that isn't documented is not a process—it's a habit. We document everything. We share what we learn, and our internal tools, openly.</li>
                        <li><strong class="font-semibold text-stone-800">Feedback as Data.</strong> Feedback is not criticism; it is data. We use our products to gather data on the effectiveness of our process.</li>
                    </ul>
                </section>
                
                 <section data-section="3" class="min-h-[50vh] py-16">
                    <h2 class="text-3xl md:text-4xl font-bold text-stone-900 mb-8">Data-Driven Refinement</h2>
                    <p class="text-stone-600">Our system is in a constant state of refinement. We use data and patterns to track what works and what doesn't. We measure everything, find the bottlenecks, and eliminate them.</p>
                </section>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const manifestoContent = document.getElementById('manifesto-content');
            const animationContainer = document.getElementById('animation-container');
            const sections = document.querySelectorAll('[data-section]');
            const svgNS = "http://www.w3.org/2000/svg";

            let currentAnimation = -1;
            let animationFrameId;

            // --- GRID SETUP ---
            function setupGrid() {
                const svg = document.createElementNS(svgNS, 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                const w = window.innerWidth;
                const h = window.innerHeight;
                svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
                svg.style.overflow = 'visible';
                animationContainer.innerHTML = '';
                animationContainer.appendChild(svg);
                
                const gridSize = 1500;
                const step = 100;

                const gWrapper = document.createElementNS(svgNS, 'g');
                gWrapper.id = 'grid-wrapper';

                const gVertical = document.createElementNS(svgNS, 'g');
                gVertical.id = 'g-vertical';
                const gHorizontal = document.createElementNS(svgNS, 'g');
                gHorizontal.id = 'g-horizontal';

                for (let i = 0; i <= gridSize; i += step) {
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', i);
                    line.setAttribute('y1', 0);
                    line.setAttribute('x2', i);
                    line.setAttribute('y2', gridSize);
                    line.setAttribute('stroke', 'rgba(28, 25, 23, 0.2)');
                    line.setAttribute('stroke-width', '1');
                    gVertical.appendChild(line);
                }
                 for (let i = 0; i <= gridSize; i += step) {
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', i);
                    line.setAttribute('x2', gridSize);
                    line.setAttribute('y2', i);
                    line.setAttribute('stroke', 'rgba(28, 25, 23, 0.2)');
                    line.setAttribute('stroke-width', '1');
                    gHorizontal.appendChild(line);
                }
                
                gWrapper.appendChild(gVertical);
                gWrapper.appendChild(gHorizontal);
                svg.appendChild(gWrapper);

                // Center the grid with a slight rightward offset
                const initialX = (w - gridSize) / 2 + 200;
                const initialY = (h - gridSize) / 2;
                gWrapper.style.transform = `translate(${initialX}px, ${initialY}px)`;
            }

            // --- GRID MORPHING LOGIC ---
            function morphGrid(index) {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const gridSize = 1500;
                
                const gWrapper = document.getElementById('grid-wrapper');
                const gVertical = document.getElementById('g-vertical');
                const gHorizontal = document.getElementById('g-horizontal');
                const vLines = gVertical.querySelectorAll('line');
                const hLines = gHorizontal.querySelectorAll('line');

                // Reset individual line transforms before applying new group transforms
                vLines.forEach(line => line.style.transform = 'none');
                hLines.forEach(line => line.style.transform = 'none');
                
                // Base position for the grid wrapper
                const initialX = (w - gridSize) / 2 + 200;
                const initialY = (h - gridSize) / 2;
                const centerX = gridSize / 2;
                const centerY = gridSize / 2;

                switch(index % 4) {
                    case 0: // Standard Grid
                        gWrapper.style.transform = `translate(${initialX}px, ${initialY}px)`;
                        break;
                    case 1: // Angled Grid
                        gWrapper.style.transform = `translate(${initialX}px, ${initialY}px) translate(${centerX}px, ${centerY}px) rotate(30deg) translate(${-centerX}px, ${-centerY}px)`;
                        break;
                    case 2: // Perspective/Zoom Grid
                         gWrapper.style.transform = `translate(${initialX}px, ${initialY}px) translate(${centerX}px, ${centerY}px) scale(1.2) translate(${-centerX}px, ${-centerY}px)`;
                        break;
                    case 3: // Wave Offset Grid
                        gWrapper.style.transform = `translate(${initialX}px, ${initialY}px)`; // Reset group transform for wave
                        hLines.forEach((line, i) => {
                             const offset = Math.sin(i * 0.5) * 30;
                             line.style.transform = `translateY(${offset}px)`;
                        });
                        vLines.forEach((line, i) => {
                             const offset = Math.cos(i * 0.5) * 30;
                             line.style.transform = `translateX(${offset}px)`;
                        });
                        break;
                }
            }


            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const sectionIndex = parseInt(entry.target.dataset.section);
                        if (sectionIndex !== currentAnimation) {
                            currentAnimation = sectionIndex;
                            morphGrid(sectionIndex);
                        }
                    }
                });
            }, { root: manifestoContent, threshold: 0.5, rootMargin: "-25% 0px -25% 0px" });

            sections.forEach(section => observer.observe(section));

            // Handle 3D rotation on scroll
            function handleScroll() {
                const scrollableHeight = manifestoContent.scrollHeight - manifestoContent.clientHeight;
                const scrollTop = manifestoContent.scrollTop;
                const scrollPercent = scrollTop / scrollableHeight;
                
                const rotateX = 15 - (scrollPercent * 10); // From 15deg down to 5deg
                const rotateY = -15 + (scrollPercent * 10); // From -15deg to -5deg
                
                cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(() => {
                    animationContainer.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                });
            }

            manifestoContent.addEventListener('scroll', handleScroll);
            
            // Initial setup
            setupGrid();
            morphGrid(0);
            handleScroll();
        });
    </script>
</body>
</html>




